"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@vercel/edge-config/dist/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/@vercel/edge-config/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clone: () => (/* binding */ clone3),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   digest: () => (/* binding */ digest),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAll: () => (/* binding */ getAll),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   parseConnectionString: () => (/* binding */ parseConnectionString),\n/* harmony export */   setTracerProvider: () => (/* binding */ setTracerProvider)\n/* harmony export */ });\n/* harmony import */ var _vercel_edge_config_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vercel/edge-config-fs */ \"node:fs/promises\");\n// src/index.ts\n\n\n// package.json\nvar name = \"@vercel/edge-config\";\nvar version = \"1.4.0\";\n\n// src/utils/tracing.ts\nvar edgeConfigTraceSymbol = Symbol.for(\"@vercel/edge-config:global-trace\");\nfunction setTracerProvider(tracer) {\n  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);\n}\nfunction getTracer() {\n  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol);\n  return maybeTraceApi == null ? void 0 : maybeTraceApi.getTracer(name, version);\n}\nfunction isPromise(p) {\n  return p !== null && typeof p === \"object\" && \"then\" in p && typeof p.then === \"function\";\n}\nfunction trace(fn, options = {\n  name: fn.name\n}) {\n  const traced = function(...args) {\n    const tracer = getTracer();\n    if (!tracer) return fn.apply(this, args);\n    const shouldTrace = process.env.EDGE_CONFIG_TRACE_VERBOSE === \"true\" || options.isVerboseTrace === false;\n    if (!shouldTrace) return fn.apply(this, args);\n    return tracer.startActiveSpan(options.name, (span) => {\n      if (options.attributes) span.setAttributes(options.attributes);\n      try {\n        const result = fn.apply(this, args);\n        if (isPromise(result)) {\n          result.then((value) => {\n            if (options.attributesSuccess) {\n              span.setAttributes(\n                options.attributesSuccess(\n                  value\n                )\n              );\n            }\n            span.setStatus({ code: 1 });\n            span.end();\n          }).catch((error) => {\n            if (options.attributesError) {\n              span.setAttributes(options.attributesError(error));\n            }\n            span.setStatus({\n              code: 2,\n              // 2 = Error\n              message: error instanceof Error ? error.message : void 0\n            });\n            span.end();\n          });\n        } else {\n          if (options.attributesSuccess) {\n            span.setAttributes(options.attributesSuccess(result));\n          }\n          span.setStatus({ code: 1 });\n          span.end();\n        }\n        return result;\n      } catch (error) {\n        if (options.attributesError) {\n          span.setAttributes(options.attributesError(error));\n        }\n        span.setStatus({\n          code: 2,\n          // 2 = Error\n          message: error instanceof Error ? error.message : void 0\n        });\n        span.end();\n        throw error;\n      }\n    });\n  };\n  return traced;\n}\n\n// src/utils/index.ts\nvar ERRORS = {\n  UNAUTHORIZED: \"@vercel/edge-config: Unauthorized\",\n  EDGE_CONFIG_NOT_FOUND: \"@vercel/edge-config: Edge Config not found\"\n};\nvar UnexpectedNetworkError = class extends Error {\n  constructor(res) {\n    super(\n      `@vercel/edge-config: Unexpected error due to response with status code ${res.status}`\n    );\n  }\n};\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction pick(obj, keys) {\n  const ret = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret;\n}\nfunction assertIsKey(key) {\n  if (typeof key !== \"string\") {\n    throw new Error(\"@vercel/edge-config: Expected key to be a string\");\n  }\n}\nfunction isEmptyKey(key) {\n  return key.trim() === \"\";\n}\nfunction assertIsKeys(keys) {\n  if (!Array.isArray(keys) || keys.some((key) => typeof key !== \"string\")) {\n    throw new Error(\n      \"@vercel/edge-config: Expected keys to be an array of string\"\n    );\n  }\n}\nvar clone = trace(\n  function clone2(value) {\n    if (typeof structuredClone === \"function\") return structuredClone(value);\n    if (value === void 0) return value;\n    return JSON.parse(JSON.stringify(value));\n  },\n  { name: \"clone\" }\n);\nfunction parseVercelConnectionStringFromUrl(text) {\n  try {\n    const url = new URL(text);\n    if (url.host !== \"edge-config.vercel.com\") return null;\n    if (url.protocol !== \"https:\") return null;\n    if (!url.pathname.startsWith(\"/ecfg\")) return null;\n    const id = url.pathname.split(\"/\")[1];\n    if (!id) return null;\n    const token = url.searchParams.get(\"token\");\n    if (!token || token === \"\") return null;\n    return {\n      type: \"vercel\",\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: \"1\",\n      token\n    };\n  } catch {\n    return null;\n  }\n}\nfunction parseConnectionFromQueryParams(text) {\n  try {\n    if (!text.startsWith(\"edge-config:\")) return null;\n    const params = new URLSearchParams(text.slice(12));\n    const id = params.get(\"id\");\n    const token = params.get(\"token\");\n    if (!id || !token) return null;\n    return {\n      type: \"vercel\",\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: \"1\",\n      token\n    };\n  } catch {\n  }\n  return null;\n}\nfunction parseExternalConnectionStringFromUrl(connectionString) {\n  try {\n    const url = new URL(connectionString);\n    let id = url.searchParams.get(\"id\");\n    const token = url.searchParams.get(\"token\");\n    const version2 = url.searchParams.get(\"version\") || \"1\";\n    if (!id || url.pathname.startsWith(\"/ecfg_\")) {\n      id = url.pathname.split(\"/\")[1] || null;\n    }\n    if (!id || !token) return null;\n    url.search = \"\";\n    return {\n      type: \"external\",\n      baseUrl: url.toString(),\n      id,\n      token,\n      version: version2\n    };\n  } catch {\n    return null;\n  }\n}\nfunction parseConnectionString(connectionString) {\n  return parseConnectionFromQueryParams(connectionString) || parseVercelConnectionStringFromUrl(connectionString) || parseExternalConnectionStringFromUrl(connectionString);\n}\n\n// src/utils/fetch-with-cached-response.ts\nfunction createResponse(cachedResponseEntry) {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n        // age header may not be 0 when serving stale content, must be >= 1\n        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1e3))\n      )\n    },\n    status: cachedResponseEntry.status\n  });\n}\nfunction createHandleStaleIfError(cachedResponseEntry, staleIfError) {\n  return function handleStaleIfError(response) {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3 ? createResponse(cachedResponseEntry) : response;\n      default:\n        return response;\n    }\n  };\n}\nfunction createHandleStaleIfErrorException(cachedResponseEntry, staleIfError) {\n  return function handleStaleIfError(reason) {\n    if (typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\nvar cache = /* @__PURE__ */ new Map();\nfunction extractStaleIfError(cacheControlHeader) {\n  if (!cacheControlHeader) return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(\n    cacheControlHeader\n  );\n  return (matched == null ? void 0 : matched.groups) ? Number(matched.groups.staleIfError) : null;\n}\nvar fetchWithCachedResponse = trace(\n  async function fetchWithCachedResponse2(url, options = {}) {\n    const { headers: customHeaders = new Headers(), ...customOptions } = options;\n    const authHeader = customHeaders.get(\"Authorization\");\n    const cacheKey = `${url},${authHeader || \"\"}`;\n    const cachedResponseEntry = cache.get(cacheKey);\n    if (cachedResponseEntry) {\n      const { etag: etag2, response: cachedResponse } = cachedResponseEntry;\n      const headers = new Headers(customHeaders);\n      headers.set(\"If-None-Match\", etag2);\n      const staleIfError = extractStaleIfError(headers.get(\"Cache-Control\"));\n      const res2 = await fetch(url, {\n        ...customOptions,\n        headers\n      }).then(\n        createHandleStaleIfError(cachedResponseEntry, staleIfError),\n        createHandleStaleIfErrorException(cachedResponseEntry, staleIfError)\n      );\n      if (res2.status === 304) {\n        res2.cachedResponseBody = JSON.parse(cachedResponse);\n        return res2;\n      }\n      const newETag = res2.headers.get(\"ETag\");\n      if (res2.ok && newETag)\n        cache.set(cacheKey, {\n          etag: newETag,\n          response: await res2.clone().text(),\n          headers: Object.fromEntries(res2.headers.entries()),\n          status: res2.status,\n          time: Date.now()\n        });\n      return res2;\n    }\n    const res = await fetch(url, options);\n    const etag = res.headers.get(\"ETag\");\n    if (res.ok && etag) {\n      cache.set(cacheKey, {\n        etag,\n        response: await res.clone().text(),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        time: Date.now()\n      });\n    }\n    return res;\n  },\n  {\n    name: \"fetchWithCachedResponse\",\n    attributesSuccess(result) {\n      return {\n        status: result.status\n      };\n    }\n  }\n);\n\n// src/index.ts\nvar jsonParseCache = /* @__PURE__ */ new Map();\nvar readFileTraced = trace(_vercel_edge_config_fs__WEBPACK_IMPORTED_MODULE_0__.readFile, { name: \"readFile\" });\nvar jsonParseTraced = trace(JSON.parse, { name: \"JSON.parse\" });\nvar privateEdgeConfigSymbol = Symbol.for(\"privateEdgeConfig\");\nvar cachedJsonParseTraced = trace(\n  (edgeConfigId, content) => {\n    const cached = jsonParseCache.get(edgeConfigId);\n    if (cached) return cached;\n    const parsed = jsonParseTraced(content);\n    jsonParseCache.set(edgeConfigId, Object.freeze(parsed));\n    return parsed;\n  },\n  { name: \"cached JSON.parse\" }\n);\nvar getFileSystemEdgeConfig = trace(\n  async function getFileSystemEdgeConfig2(connection) {\n    if (connection.type !== \"vercel\") return null;\n    if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n    try {\n      const content = await readFileTraced(\n        `/opt/edge-config/${connection.id}.json`,\n        \"utf-8\"\n      );\n      return cachedJsonParseTraced(\n        connection.id,\n        content\n      );\n    } catch {\n      return null;\n    }\n  },\n  {\n    name: \"getFileSystemEdgeConfig\"\n  }\n);\nvar getPrivateEdgeConfig = trace(\n  async function getPrivateEdgeConfig2(connection) {\n    const privateEdgeConfig = Reflect.get(\n      globalThis,\n      privateEdgeConfigSymbol\n    );\n    if (typeof privateEdgeConfig === \"object\" && typeof privateEdgeConfig.get === \"function\") {\n      return privateEdgeConfig.get(connection.id);\n    }\n    return null;\n  },\n  {\n    name: \"getPrivateEdgeConfig\"\n  }\n);\nfunction createGetInMemoryEdgeConfig(shouldUseDevelopmentCache, connection, headers, fetchCache) {\n  let embeddedEdgeConfigPromise = null;\n  let latestRequest = null;\n  return trace(\n    (localOptions) => {\n      if ((localOptions == null ? void 0 : localOptions.consistentRead) || !shouldUseDevelopmentCache)\n        return Promise.resolve(null);\n      if (!latestRequest) {\n        latestRequest = fetchWithCachedResponse(\n          `${connection.baseUrl}/items?version=${connection.version}`,\n          {\n            headers: new Headers(headers),\n            cache: fetchCache\n          }\n        ).then(async (res) => {\n          const digest2 = res.headers.get(\"x-edge-config-digest\");\n          let body;\n          if (!res.ok) {\n            await consumeResponseBody(res);\n            body = res.cachedResponseBody;\n            if (!body) return null;\n          } else {\n            body = await res.json();\n          }\n          return { digest: digest2, items: body };\n        });\n        latestRequest.then(\n          (resolved) => {\n            embeddedEdgeConfigPromise = Promise.resolve(resolved);\n            latestRequest = null;\n          },\n          // Attach a `.catch` handler to this promise so that if it does throw,\n          // we don't get an unhandled promise rejection event. We unset the\n          // `latestRequest` so that the next call will make a new request.\n          () => {\n            embeddedEdgeConfigPromise = null;\n            latestRequest = null;\n          }\n        );\n      }\n      if (!embeddedEdgeConfigPromise) {\n        embeddedEdgeConfigPromise = latestRequest;\n      }\n      return embeddedEdgeConfigPromise;\n    },\n    {\n      name: \"getInMemoryEdgeConfig\"\n    }\n  );\n}\nfunction addConsistentReadHeader(headers) {\n  headers.set(\"x-edge-config-min-updated-at\", `${Number.MAX_SAFE_INTEGER}`);\n}\nasync function getLocalEdgeConfig(connection, options) {\n  if (options == null ? void 0 : options.consistentRead) return null;\n  const edgeConfig = await getPrivateEdgeConfig(connection) || await getFileSystemEdgeConfig(connection);\n  return edgeConfig;\n}\nasync function consumeResponseBody(res) {\n  await res.arrayBuffer();\n}\nvar createClient = trace(\n  function createClient2(connectionString, options = {\n    staleIfError: 604800,\n    cache: \"no-store\"\n  }) {\n    if (!connectionString)\n      throw new Error(\"@vercel/edge-config: No connection string provided\");\n    const connection = parseConnectionString(connectionString);\n    if (!connection)\n      throw new Error(\n        \"@vercel/edge-config: Invalid connection string provided\"\n      );\n    const edgeConfigId = connection.id;\n    const baseUrl = connection.baseUrl;\n    const version2 = connection.version;\n    const headers = {\n      Authorization: `Bearer ${connection.token}`\n    };\n    if (typeof process !== \"undefined\" && process.env.VERCEL_ENV)\n      headers[\"x-edge-config-vercel-env\"] = process.env.VERCEL_ENV;\n    if (typeof name === \"string\" && typeof version === \"string\")\n      headers[\"x-edge-config-sdk\"] = `${name}@${version}`;\n    if (typeof options.staleIfError === \"number\" && options.staleIfError > 0)\n      headers[\"cache-control\"] = `stale-if-error=${options.staleIfError}`;\n    const fetchCache = options.cache || \"no-store\";\n    const shouldUseDevelopmentCache = !options.disableDevelopmentCache && \"development\" === \"development\" && process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== \"1\";\n    const getInMemoryEdgeConfig = createGetInMemoryEdgeConfig(\n      shouldUseDevelopmentCache,\n      connection,\n      headers,\n      fetchCache\n    );\n    const api = {\n      get: trace(\n        async function get2(key, localOptions) {\n          const localEdgeConfig = await getInMemoryEdgeConfig(localOptions) || await getLocalEdgeConfig(connection, localOptions);\n          assertIsKey(key);\n          if (isEmptyKey(key)) return void 0;\n          if (localEdgeConfig) {\n            return Promise.resolve(localEdgeConfig.items[key]);\n          }\n          const localHeaders = new Headers(headers);\n          if (localOptions == null ? void 0 : localOptions.consistentRead)\n            addConsistentReadHeader(localHeaders);\n          return fetchWithCachedResponse(\n            `${baseUrl}/item/${key}?version=${version2}`,\n            {\n              headers: localHeaders,\n              cache: fetchCache\n            }\n          ).then(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              if (res.headers.has(\"x-edge-config-digest\")) return void 0;\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.cachedResponseBody !== void 0)\n              return res.cachedResponseBody;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: \"get\", isVerboseTrace: false, attributes: { edgeConfigId } }\n      ),\n      has: trace(\n        async function has2(key, localOptions) {\n          const localEdgeConfig = await getInMemoryEdgeConfig(localOptions) || await getLocalEdgeConfig(connection, localOptions);\n          assertIsKey(key);\n          if (isEmptyKey(key)) return false;\n          if (localEdgeConfig) {\n            return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n          }\n          const localHeaders = new Headers(headers);\n          if (localOptions == null ? void 0 : localOptions.consistentRead)\n            addConsistentReadHeader(localHeaders);\n          return fetch(`${baseUrl}/item/${key}?version=${version2}`, {\n            method: \"HEAD\",\n            headers: localHeaders,\n            cache: fetchCache\n          }).then((res) => {\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              if (res.headers.has(\"x-edge-config-digest\")) return false;\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.ok) return true;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: \"has\", isVerboseTrace: false, attributes: { edgeConfigId } }\n      ),\n      getAll: trace(\n        async function getAll2(keys, localOptions) {\n          const localEdgeConfig = await getInMemoryEdgeConfig(localOptions) || await getLocalEdgeConfig(connection, localOptions);\n          if (localEdgeConfig) {\n            if (keys === void 0) {\n              return Promise.resolve(localEdgeConfig.items);\n            }\n            assertIsKeys(keys);\n            return Promise.resolve(pick(localEdgeConfig.items, keys));\n          }\n          if (Array.isArray(keys)) assertIsKeys(keys);\n          const search = Array.isArray(keys) ? new URLSearchParams(\n            keys.filter((key) => typeof key === \"string\" && !isEmptyKey(key)).map((key) => [\"key\", key])\n          ).toString() : null;\n          if (search === \"\") return Promise.resolve({});\n          const localHeaders = new Headers(headers);\n          if (localOptions == null ? void 0 : localOptions.consistentRead)\n            addConsistentReadHeader(localHeaders);\n          return fetchWithCachedResponse(\n            `${baseUrl}/items?version=${version2}${search === null ? \"\" : `&${search}`}`,\n            {\n              headers: localHeaders,\n              cache: fetchCache\n            }\n          ).then(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404)\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            if (res.cachedResponseBody !== void 0)\n              return res.cachedResponseBody;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: \"getAll\", isVerboseTrace: false, attributes: { edgeConfigId } }\n      ),\n      digest: trace(\n        async function digest2(localOptions) {\n          const localEdgeConfig = await getInMemoryEdgeConfig(localOptions) || await getLocalEdgeConfig(connection, localOptions);\n          if (localEdgeConfig) {\n            return Promise.resolve(localEdgeConfig.digest);\n          }\n          const localHeaders = new Headers(headers);\n          if (localOptions == null ? void 0 : localOptions.consistentRead)\n            addConsistentReadHeader(localHeaders);\n          return fetchWithCachedResponse(\n            `${baseUrl}/digest?version=${version2}`,\n            {\n              headers: localHeaders,\n              cache: fetchCache\n            }\n          ).then(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n            if (res.cachedResponseBody !== void 0)\n              return res.cachedResponseBody;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: \"digest\", isVerboseTrace: false, attributes: { edgeConfigId } }\n      )\n    };\n    return { ...api, connection };\n  },\n  {\n    name: \"createClient\"\n  }\n);\nvar defaultEdgeConfigClient;\nfunction init() {\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\nvar get = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\nvar getAll = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\nvar has = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\nvar digest = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\nfunction clone3(edgeConfigValue) {\n  return JSON.parse(JSON.stringify(edgeConfigValue));\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvZWRnZS1jb25maWcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsV0FBVztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMveWFob3JiYXJrb3Vza2kvdGhlbmV0d29yay9lZGdlLWZlYXR1cmUtZmxhZ3Mvbm9kZV9tb2R1bGVzL0B2ZXJjZWwvZWRnZS1jb25maWcvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IHJlYWRGaWxlIH0gZnJvbSBcIkB2ZXJjZWwvZWRnZS1jb25maWctZnNcIjtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgbmFtZSA9IFwiQHZlcmNlbC9lZGdlLWNvbmZpZ1wiO1xudmFyIHZlcnNpb24gPSBcIjEuNC4wXCI7XG5cbi8vIHNyYy91dGlscy90cmFjaW5nLnRzXG52YXIgZWRnZUNvbmZpZ1RyYWNlU3ltYm9sID0gU3ltYm9sLmZvcihcIkB2ZXJjZWwvZWRnZS1jb25maWc6Z2xvYmFsLXRyYWNlXCIpO1xuZnVuY3Rpb24gc2V0VHJhY2VyUHJvdmlkZXIodHJhY2VyKSB7XG4gIFJlZmxlY3Quc2V0KGdsb2JhbFRoaXMsIGVkZ2VDb25maWdUcmFjZVN5bWJvbCwgdHJhY2VyKTtcbn1cbmZ1bmN0aW9uIGdldFRyYWNlcigpIHtcbiAgY29uc3QgbWF5YmVUcmFjZUFwaSA9IFJlZmxlY3QuZ2V0KGdsb2JhbFRoaXMsIGVkZ2VDb25maWdUcmFjZVN5bWJvbCk7XG4gIHJldHVybiBtYXliZVRyYWNlQXBpID09IG51bGwgPyB2b2lkIDAgOiBtYXliZVRyYWNlQXBpLmdldFRyYWNlcihuYW1lLCB2ZXJzaW9uKTtcbn1cbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gIHJldHVybiBwICE9PSBudWxsICYmIHR5cGVvZiBwID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHAgJiYgdHlwZW9mIHAudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gdHJhY2UoZm4sIG9wdGlvbnMgPSB7XG4gIG5hbWU6IGZuLm5hbWVcbn0pIHtcbiAgY29uc3QgdHJhY2VkID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGlmICghdHJhY2VyKSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgY29uc3Qgc2hvdWxkVHJhY2UgPSBwcm9jZXNzLmVudi5FREdFX0NPTkZJR19UUkFDRV9WRVJCT1NFID09PSBcInRydWVcIiB8fCBvcHRpb25zLmlzVmVyYm9zZVRyYWNlID09PSBmYWxzZTtcbiAgICBpZiAoIXNob3VsZFRyYWNlKSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4ob3B0aW9ucy5uYW1lLCAoc3BhbikgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgc3Bhbi5zZXRBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzU3VjY2Vzcykge1xuICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzU3VjY2VzcyhcbiAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiAxIH0pO1xuICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXNFcnJvcikge1xuICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgY29kZTogMixcbiAgICAgICAgICAgICAgLy8gMiA9IEVycm9yXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXNTdWNjZXNzKHJlc3VsdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IDEgfSk7XG4gICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlc0Vycm9yKSB7XG4gICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlc0Vycm9yKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgIGNvZGU6IDIsXG4gICAgICAgICAgLy8gMiA9IEVycm9yXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gdHJhY2VkO1xufVxuXG4vLyBzcmMvdXRpbHMvaW5kZXgudHNcbnZhciBFUlJPUlMgPSB7XG4gIFVOQVVUSE9SSVpFRDogXCJAdmVyY2VsL2VkZ2UtY29uZmlnOiBVbmF1dGhvcml6ZWRcIixcbiAgRURHRV9DT05GSUdfTk9UX0ZPVU5EOiBcIkB2ZXJjZWwvZWRnZS1jb25maWc6IEVkZ2UgQ29uZmlnIG5vdCBmb3VuZFwiXG59O1xudmFyIFVuZXhwZWN0ZWROZXR3b3JrRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgc3VwZXIoXG4gICAgICBgQHZlcmNlbC9lZGdlLWNvbmZpZzogVW5leHBlY3RlZCBlcnJvciBkdWUgdG8gcmVzcG9uc2Ugd2l0aCBzdGF0dXMgY29kZSAke3Jlcy5zdGF0dXN9YFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0tleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJAdmVyY2VsL2VkZ2UtY29uZmlnOiBFeHBlY3RlZCBrZXkgdG8gYmUgYSBzdHJpbmdcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRW1wdHlLZXkoa2V5KSB7XG4gIHJldHVybiBrZXkudHJpbSgpID09PSBcIlwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNLZXlzKGtleXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpIHx8IGtleXMuc29tZSgoa2V5KSA9PiB0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogRXhwZWN0ZWQga2V5cyB0byBiZSBhbiBhcnJheSBvZiBzdHJpbmdcIlxuICAgICk7XG4gIH1cbn1cbnZhciBjbG9uZSA9IHRyYWNlKFxuICBmdW5jdGlvbiBjbG9uZTIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gc3RydWN0dXJlZENsb25lKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH0sXG4gIHsgbmFtZTogXCJjbG9uZVwiIH1cbik7XG5mdW5jdGlvbiBwYXJzZVZlcmNlbENvbm5lY3Rpb25TdHJpbmdGcm9tVXJsKHRleHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRleHQpO1xuICAgIGlmICh1cmwuaG9zdCAhPT0gXCJlZGdlLWNvbmZpZy52ZXJjZWwuY29tXCIpIHJldHVybiBudWxsO1xuICAgIGlmICh1cmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpIHJldHVybiBudWxsO1xuICAgIGlmICghdXJsLnBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvZWNmZ1wiKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaWQgPSB1cmwucGF0aG5hbWUuc3BsaXQoXCIvXCIpWzFdO1xuICAgIGlmICghaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcbiAgICBpZiAoIXRva2VuIHx8IHRva2VuID09PSBcIlwiKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ2ZXJjZWxcIixcbiAgICAgIGJhc2VVcmw6IGBodHRwczovL2VkZ2UtY29uZmlnLnZlcmNlbC5jb20vJHtpZH1gLFxuICAgICAgaWQsXG4gICAgICB2ZXJzaW9uOiBcIjFcIixcbiAgICAgIHRva2VuXG4gICAgfTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvbkZyb21RdWVyeVBhcmFtcyh0ZXh0KSB7XG4gIHRyeSB7XG4gICAgaWYgKCF0ZXh0LnN0YXJ0c1dpdGgoXCJlZGdlLWNvbmZpZzpcIikpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModGV4dC5zbGljZSgxMikpO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zLmdldChcImlkXCIpO1xuICAgIGNvbnN0IHRva2VuID0gcGFyYW1zLmdldChcInRva2VuXCIpO1xuICAgIGlmICghaWQgfHwgIXRva2VuKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ2ZXJjZWxcIixcbiAgICAgIGJhc2VVcmw6IGBodHRwczovL2VkZ2UtY29uZmlnLnZlcmNlbC5jb20vJHtpZH1gLFxuICAgICAgaWQsXG4gICAgICB2ZXJzaW9uOiBcIjFcIixcbiAgICAgIHRva2VuXG4gICAgfTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUV4dGVybmFsQ29ubmVjdGlvblN0cmluZ0Zyb21VcmwoY29ubmVjdGlvblN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY29ubmVjdGlvblN0cmluZyk7XG4gICAgbGV0IGlkID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJpZFwiKTtcbiAgICBjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidG9rZW5cIik7XG4gICAgY29uc3QgdmVyc2lvbjIgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcInZlcnNpb25cIikgfHwgXCIxXCI7XG4gICAgaWYgKCFpZCB8fCB1cmwucGF0aG5hbWUuc3RhcnRzV2l0aChcIi9lY2ZnX1wiKSkge1xuICAgICAgaWQgPSB1cmwucGF0aG5hbWUuc3BsaXQoXCIvXCIpWzFdIHx8IG51bGw7XG4gICAgfVxuICAgIGlmICghaWQgfHwgIXRva2VuKSByZXR1cm4gbnVsbDtcbiAgICB1cmwuc2VhcmNoID0gXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJleHRlcm5hbFwiLFxuICAgICAgYmFzZVVybDogdXJsLnRvU3RyaW5nKCksXG4gICAgICBpZCxcbiAgICAgIHRva2VuLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbjJcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlQ29ubmVjdGlvbkZyb21RdWVyeVBhcmFtcyhjb25uZWN0aW9uU3RyaW5nKSB8fCBwYXJzZVZlcmNlbENvbm5lY3Rpb25TdHJpbmdGcm9tVXJsKGNvbm5lY3Rpb25TdHJpbmcpIHx8IHBhcnNlRXh0ZXJuYWxDb25uZWN0aW9uU3RyaW5nRnJvbVVybChjb25uZWN0aW9uU3RyaW5nKTtcbn1cblxuLy8gc3JjL3V0aWxzL2ZldGNoLXdpdGgtY2FjaGVkLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZShjYWNoZWRSZXNwb25zZUVudHJ5KSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoY2FjaGVkUmVzcG9uc2VFbnRyeS5yZXNwb25zZSwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmNhY2hlZFJlc3BvbnNlRW50cnkuaGVhZGVycyxcbiAgICAgIEFnZTogU3RyaW5nKFxuICAgICAgICAvLyBhZ2UgaGVhZGVyIG1heSBub3QgYmUgMCB3aGVuIHNlcnZpbmcgc3RhbGUgY29udGVudCwgbXVzdCBiZSA+PSAxXG4gICAgICAgIE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBjYWNoZWRSZXNwb25zZUVudHJ5LnRpbWUpIC8gMWUzKSlcbiAgICAgIClcbiAgICB9LFxuICAgIHN0YXR1czogY2FjaGVkUmVzcG9uc2VFbnRyeS5zdGF0dXNcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVIYW5kbGVTdGFsZUlmRXJyb3IoY2FjaGVkUmVzcG9uc2VFbnRyeSwgc3RhbGVJZkVycm9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVTdGFsZUlmRXJyb3IocmVzcG9uc2UpIHtcbiAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgY2FzZSA1MDA6XG4gICAgICBjYXNlIDUwMjpcbiAgICAgIGNhc2UgNTAzOlxuICAgICAgY2FzZSA1MDQ6XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RhbGVJZkVycm9yID09PSBcIm51bWJlclwiICYmIGNhY2hlZFJlc3BvbnNlRW50cnkudGltZSA8IERhdGUubm93KCkgKyBzdGFsZUlmRXJyb3IgKiAxZTMgPyBjcmVhdGVSZXNwb25zZShjYWNoZWRSZXNwb25zZUVudHJ5KSA6IHJlc3BvbnNlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhbmRsZVN0YWxlSWZFcnJvckV4Y2VwdGlvbihjYWNoZWRSZXNwb25zZUVudHJ5LCBzdGFsZUlmRXJyb3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZVN0YWxlSWZFcnJvcihyZWFzb24pIHtcbiAgICBpZiAodHlwZW9mIHN0YWxlSWZFcnJvciA9PT0gXCJudW1iZXJcIiAmJiBjYWNoZWRSZXNwb25zZUVudHJ5LnRpbWUgPCBEYXRlLm5vdygpICsgc3RhbGVJZkVycm9yICogMWUzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVzcG9uc2UoY2FjaGVkUmVzcG9uc2VFbnRyeSk7XG4gICAgfVxuICAgIHRocm93IHJlYXNvbjtcbiAgfTtcbn1cbnZhciBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBleHRyYWN0U3RhbGVJZkVycm9yKGNhY2hlQ29udHJvbEhlYWRlcikge1xuICBpZiAoIWNhY2hlQ29udHJvbEhlYWRlcikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG1hdGNoZWQgPSAvc3RhbGUtaWYtZXJyb3I9KD88c3RhbGVJZkVycm9yPlxcZCspL2kuZXhlYyhcbiAgICBjYWNoZUNvbnRyb2xIZWFkZXJcbiAgKTtcbiAgcmV0dXJuIChtYXRjaGVkID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaGVkLmdyb3VwcykgPyBOdW1iZXIobWF0Y2hlZC5ncm91cHMuc3RhbGVJZkVycm9yKSA6IG51bGw7XG59XG52YXIgZmV0Y2hXaXRoQ2FjaGVkUmVzcG9uc2UgPSB0cmFjZShcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoQ2FjaGVkUmVzcG9uc2UyKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBoZWFkZXJzOiBjdXN0b21IZWFkZXJzID0gbmV3IEhlYWRlcnMoKSwgLi4uY3VzdG9tT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gY3VzdG9tSGVhZGVycy5nZXQoXCJBdXRob3JpemF0aW9uXCIpO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7dXJsfSwke2F1dGhIZWFkZXIgfHwgXCJcIn1gO1xuICAgIGNvbnN0IGNhY2hlZFJlc3BvbnNlRW50cnkgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChjYWNoZWRSZXNwb25zZUVudHJ5KSB7XG4gICAgICBjb25zdCB7IGV0YWc6IGV0YWcyLCByZXNwb25zZTogY2FjaGVkUmVzcG9uc2UgfSA9IGNhY2hlZFJlc3BvbnNlRW50cnk7XG4gICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoY3VzdG9tSGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIklmLU5vbmUtTWF0Y2hcIiwgZXRhZzIpO1xuICAgICAgY29uc3Qgc3RhbGVJZkVycm9yID0gZXh0cmFjdFN0YWxlSWZFcnJvcihoZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIikpO1xuICAgICAgY29uc3QgcmVzMiA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KS50aGVuKFxuICAgICAgICBjcmVhdGVIYW5kbGVTdGFsZUlmRXJyb3IoY2FjaGVkUmVzcG9uc2VFbnRyeSwgc3RhbGVJZkVycm9yKSxcbiAgICAgICAgY3JlYXRlSGFuZGxlU3RhbGVJZkVycm9yRXhjZXB0aW9uKGNhY2hlZFJlc3BvbnNlRW50cnksIHN0YWxlSWZFcnJvcilcbiAgICAgICk7XG4gICAgICBpZiAocmVzMi5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgICByZXMyLmNhY2hlZFJlc3BvbnNlQm9keSA9IEpTT04ucGFyc2UoY2FjaGVkUmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gcmVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0VUYWcgPSByZXMyLmhlYWRlcnMuZ2V0KFwiRVRhZ1wiKTtcbiAgICAgIGlmIChyZXMyLm9rICYmIG5ld0VUYWcpXG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwge1xuICAgICAgICAgIGV0YWc6IG5ld0VUYWcsXG4gICAgICAgICAgcmVzcG9uc2U6IGF3YWl0IHJlczIuY2xvbmUoKS50ZXh0KCksXG4gICAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlczIuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICAgIHN0YXR1czogcmVzMi5zdGF0dXMsXG4gICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICB9KTtcbiAgICAgIHJldHVybiByZXMyO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGV0YWcgPSByZXMuaGVhZGVycy5nZXQoXCJFVGFnXCIpO1xuICAgIGlmIChyZXMub2sgJiYgZXRhZykge1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgIGV0YWcsXG4gICAgICAgIHJlc3BvbnNlOiBhd2FpdCByZXMuY2xvbmUoKS50ZXh0KCksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhyZXMuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICB7XG4gICAgbmFtZTogXCJmZXRjaFdpdGhDYWNoZWRSZXNwb25zZVwiLFxuICAgIGF0dHJpYnV0ZXNTdWNjZXNzKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIganNvblBhcnNlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIHJlYWRGaWxlVHJhY2VkID0gdHJhY2UocmVhZEZpbGUsIHsgbmFtZTogXCJyZWFkRmlsZVwiIH0pO1xudmFyIGpzb25QYXJzZVRyYWNlZCA9IHRyYWNlKEpTT04ucGFyc2UsIHsgbmFtZTogXCJKU09OLnBhcnNlXCIgfSk7XG52YXIgcHJpdmF0ZUVkZ2VDb25maWdTeW1ib2wgPSBTeW1ib2wuZm9yKFwicHJpdmF0ZUVkZ2VDb25maWdcIik7XG52YXIgY2FjaGVkSnNvblBhcnNlVHJhY2VkID0gdHJhY2UoXG4gIChlZGdlQ29uZmlnSWQsIGNvbnRlbnQpID0+IHtcbiAgICBjb25zdCBjYWNoZWQgPSBqc29uUGFyc2VDYWNoZS5nZXQoZWRnZUNvbmZpZ0lkKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGNvbnN0IHBhcnNlZCA9IGpzb25QYXJzZVRyYWNlZChjb250ZW50KTtcbiAgICBqc29uUGFyc2VDYWNoZS5zZXQoZWRnZUNvbmZpZ0lkLCBPYmplY3QuZnJlZXplKHBhcnNlZCkpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0sXG4gIHsgbmFtZTogXCJjYWNoZWQgSlNPTi5wYXJzZVwiIH1cbik7XG52YXIgZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWcgPSB0cmFjZShcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWcyKGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi50eXBlICE9PSBcInZlcmNlbFwiKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXByb2Nlc3MuZW52LkFXU19MQU1CREFfRlVOQ1RJT05fTkFNRSkgcmV0dXJuIG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZVRyYWNlZChcbiAgICAgICAgYC9vcHQvZWRnZS1jb25maWcvJHtjb25uZWN0aW9uLmlkfS5qc29uYCxcbiAgICAgICAgXCJ1dGYtOFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNhY2hlZEpzb25QYXJzZVRyYWNlZChcbiAgICAgICAgY29ubmVjdGlvbi5pZCxcbiAgICAgICAgY29udGVudFxuICAgICAgKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWdcIlxuICB9XG4pO1xudmFyIGdldFByaXZhdGVFZGdlQ29uZmlnID0gdHJhY2UoXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFByaXZhdGVFZGdlQ29uZmlnMihjb25uZWN0aW9uKSB7XG4gICAgY29uc3QgcHJpdmF0ZUVkZ2VDb25maWcgPSBSZWZsZWN0LmdldChcbiAgICAgIGdsb2JhbFRoaXMsXG4gICAgICBwcml2YXRlRWRnZUNvbmZpZ1N5bWJvbFxuICAgICk7XG4gICAgaWYgKHR5cGVvZiBwcml2YXRlRWRnZUNvbmZpZyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJpdmF0ZUVkZ2VDb25maWcuZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBwcml2YXRlRWRnZUNvbmZpZy5nZXQoY29ubmVjdGlvbi5pZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICB7XG4gICAgbmFtZTogXCJnZXRQcml2YXRlRWRnZUNvbmZpZ1wiXG4gIH1cbik7XG5mdW5jdGlvbiBjcmVhdGVHZXRJbk1lbW9yeUVkZ2VDb25maWcoc2hvdWxkVXNlRGV2ZWxvcG1lbnRDYWNoZSwgY29ubmVjdGlvbiwgaGVhZGVycywgZmV0Y2hDYWNoZSkge1xuICBsZXQgZW1iZWRkZWRFZGdlQ29uZmlnUHJvbWlzZSA9IG51bGw7XG4gIGxldCBsYXRlc3RSZXF1ZXN0ID0gbnVsbDtcbiAgcmV0dXJuIHRyYWNlKFxuICAgIChsb2NhbE9wdGlvbnMpID0+IHtcbiAgICAgIGlmICgobG9jYWxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBsb2NhbE9wdGlvbnMuY29uc2lzdGVudFJlYWQpIHx8ICFzaG91bGRVc2VEZXZlbG9wbWVudENhY2hlKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgaWYgKCFsYXRlc3RSZXF1ZXN0KSB7XG4gICAgICAgIGxhdGVzdFJlcXVlc3QgPSBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZShcbiAgICAgICAgICBgJHtjb25uZWN0aW9uLmJhc2VVcmx9L2l0ZW1zP3ZlcnNpb249JHtjb25uZWN0aW9uLnZlcnNpb259YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgICAgIGNhY2hlOiBmZXRjaENhY2hlXG4gICAgICAgICAgfVxuICAgICAgICApLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGRpZ2VzdDIgPSByZXMuaGVhZGVycy5nZXQoXCJ4LWVkZ2UtY29uZmlnLWRpZ2VzdFwiKTtcbiAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgYXdhaXQgY29uc3VtZVJlc3BvbnNlQm9keShyZXMpO1xuICAgICAgICAgICAgYm9keSA9IHJlcy5jYWNoZWRSZXNwb25zZUJvZHk7XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgZGlnZXN0OiBkaWdlc3QyLCBpdGVtczogYm9keSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgbGF0ZXN0UmVxdWVzdC50aGVuKFxuICAgICAgICAgIChyZXNvbHZlZCkgPT4ge1xuICAgICAgICAgICAgZW1iZWRkZWRFZGdlQ29uZmlnUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShyZXNvbHZlZCk7XG4gICAgICAgICAgICBsYXRlc3RSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIEF0dGFjaCBhIGAuY2F0Y2hgIGhhbmRsZXIgdG8gdGhpcyBwcm9taXNlIHNvIHRoYXQgaWYgaXQgZG9lcyB0aHJvdyxcbiAgICAgICAgICAvLyB3ZSBkb24ndCBnZXQgYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIGV2ZW50LiBXZSB1bnNldCB0aGVcbiAgICAgICAgICAvLyBgbGF0ZXN0UmVxdWVzdGAgc28gdGhhdCB0aGUgbmV4dCBjYWxsIHdpbGwgbWFrZSBhIG5ldyByZXF1ZXN0LlxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGVtYmVkZGVkRWRnZUNvbmZpZ1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgbGF0ZXN0UmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFlbWJlZGRlZEVkZ2VDb25maWdQcm9taXNlKSB7XG4gICAgICAgIGVtYmVkZGVkRWRnZUNvbmZpZ1Byb21pc2UgPSBsYXRlc3RSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtYmVkZGVkRWRnZUNvbmZpZ1Byb21pc2U7XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImdldEluTWVtb3J5RWRnZUNvbmZpZ1wiXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gYWRkQ29uc2lzdGVudFJlYWRIZWFkZXIoaGVhZGVycykge1xuICBoZWFkZXJzLnNldChcIngtZWRnZS1jb25maWctbWluLXVwZGF0ZWQtYXRcIiwgYCR7TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ9YCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbEVkZ2VDb25maWcoY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb25zaXN0ZW50UmVhZCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGVkZ2VDb25maWcgPSBhd2FpdCBnZXRQcml2YXRlRWRnZUNvbmZpZyhjb25uZWN0aW9uKSB8fCBhd2FpdCBnZXRGaWxlU3lzdGVtRWRnZUNvbmZpZyhjb25uZWN0aW9uKTtcbiAgcmV0dXJuIGVkZ2VDb25maWc7XG59XG5hc3luYyBmdW5jdGlvbiBjb25zdW1lUmVzcG9uc2VCb2R5KHJlcykge1xuICBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbn1cbnZhciBjcmVhdGVDbGllbnQgPSB0cmFjZShcbiAgZnVuY3Rpb24gY3JlYXRlQ2xpZW50Mihjb25uZWN0aW9uU3RyaW5nLCBvcHRpb25zID0ge1xuICAgIHN0YWxlSWZFcnJvcjogNjA0ODAwLFxuICAgIGNhY2hlOiBcIm5vLXN0b3JlXCJcbiAgfSkge1xuICAgIGlmICghY29ubmVjdGlvblN0cmluZylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkB2ZXJjZWwvZWRnZS1jb25maWc6IE5vIGNvbm5lY3Rpb24gc3RyaW5nIHByb3ZpZGVkXCIpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBwYXJzZUNvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZyk7XG4gICAgaWYgKCFjb25uZWN0aW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkB2ZXJjZWwvZWRnZS1jb25maWc6IEludmFsaWQgY29ubmVjdGlvbiBzdHJpbmcgcHJvdmlkZWRcIlxuICAgICAgKTtcbiAgICBjb25zdCBlZGdlQ29uZmlnSWQgPSBjb25uZWN0aW9uLmlkO1xuICAgIGNvbnN0IGJhc2VVcmwgPSBjb25uZWN0aW9uLmJhc2VVcmw7XG4gICAgY29uc3QgdmVyc2lvbjIgPSBjb25uZWN0aW9uLnZlcnNpb247XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25uZWN0aW9uLnRva2VufWBcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5WRVJDRUxfRU5WKVxuICAgICAgaGVhZGVyc1tcIngtZWRnZS1jb25maWctdmVyY2VsLWVudlwiXSA9IHByb2Nlc3MuZW52LlZFUkNFTF9FTlY7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2ZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgICAgaGVhZGVyc1tcIngtZWRnZS1jb25maWctc2RrXCJdID0gYCR7bmFtZX1AJHt2ZXJzaW9ufWA7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0YWxlSWZFcnJvciA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLnN0YWxlSWZFcnJvciA+IDApXG4gICAgICBoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IGBzdGFsZS1pZi1lcnJvcj0ke29wdGlvbnMuc3RhbGVJZkVycm9yfWA7XG4gICAgY29uc3QgZmV0Y2hDYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgXCJuby1zdG9yZVwiO1xuICAgIGNvbnN0IHNob3VsZFVzZURldmVsb3BtZW50Q2FjaGUgPSAhb3B0aW9ucy5kaXNhYmxlRGV2ZWxvcG1lbnRDYWNoZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiICYmIHByb2Nlc3MuZW52LkVER0VfQ09ORklHX0RJU0FCTEVfREVWRUxPUE1FTlRfU1dSICE9PSBcIjFcIjtcbiAgICBjb25zdCBnZXRJbk1lbW9yeUVkZ2VDb25maWcgPSBjcmVhdGVHZXRJbk1lbW9yeUVkZ2VDb25maWcoXG4gICAgICBzaG91bGRVc2VEZXZlbG9wbWVudENhY2hlLFxuICAgICAgY29ubmVjdGlvbixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBmZXRjaENhY2hlXG4gICAgKTtcbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICBnZXQ6IHRyYWNlKFxuICAgICAgICBhc3luYyBmdW5jdGlvbiBnZXQyKGtleSwgbG9jYWxPcHRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxFZGdlQ29uZmlnID0gYXdhaXQgZ2V0SW5NZW1vcnlFZGdlQ29uZmlnKGxvY2FsT3B0aW9ucykgfHwgYXdhaXQgZ2V0TG9jYWxFZGdlQ29uZmlnKGNvbm5lY3Rpb24sIGxvY2FsT3B0aW9ucyk7XG4gICAgICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgICAgICBpZiAoaXNFbXB0eUtleShrZXkpKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIGlmIChsb2NhbEVkZ2VDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9jYWxFZGdlQ29uZmlnLml0ZW1zW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsb2NhbEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICBpZiAobG9jYWxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBsb2NhbE9wdGlvbnMuY29uc2lzdGVudFJlYWQpXG4gICAgICAgICAgICBhZGRDb25zaXN0ZW50UmVhZEhlYWRlcihsb2NhbEhlYWRlcnMpO1xuICAgICAgICAgIHJldHVybiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZShcbiAgICAgICAgICAgIGAke2Jhc2VVcmx9L2l0ZW0vJHtrZXl9P3ZlcnNpb249JHt2ZXJzaW9uMn1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBoZWFkZXJzOiBsb2NhbEhlYWRlcnMsXG4gICAgICAgICAgICAgIGNhY2hlOiBmZXRjaENhY2hlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMub2spIHJldHVybiByZXMuanNvbigpO1xuICAgICAgICAgICAgYXdhaXQgY29uc3VtZVJlc3BvbnNlQm9keShyZXMpO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5VTkFVVEhPUklaRUQpO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICBpZiAocmVzLmhlYWRlcnMuaGFzKFwieC1lZGdlLWNvbmZpZy1kaWdlc3RcIikpIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuRURHRV9DT05GSUdfTk9UX0ZPVU5EKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMuY2FjaGVkUmVzcG9uc2VCb2R5ICE9PSB2b2lkIDApXG4gICAgICAgICAgICAgIHJldHVybiByZXMuY2FjaGVkUmVzcG9uc2VCb2R5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWROZXR3b3JrRXJyb3IocmVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBuYW1lOiBcImdldFwiLCBpc1ZlcmJvc2VUcmFjZTogZmFsc2UsIGF0dHJpYnV0ZXM6IHsgZWRnZUNvbmZpZ0lkIH0gfVxuICAgICAgKSxcbiAgICAgIGhhczogdHJhY2UoXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGhhczIoa2V5LCBsb2NhbE9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRJbk1lbW9yeUVkZ2VDb25maWcobG9jYWxPcHRpb25zKSB8fCBhd2FpdCBnZXRMb2NhbEVkZ2VDb25maWcoY29ubmVjdGlvbiwgbG9jYWxPcHRpb25zKTtcbiAgICAgICAgICBhc3NlcnRJc0tleShrZXkpO1xuICAgICAgICAgIGlmIChpc0VtcHR5S2V5KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAobG9jYWxFZGdlQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhc093blByb3BlcnR5KGxvY2FsRWRnZUNvbmZpZy5pdGVtcywga2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxvY2FsSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICAgIGlmIChsb2NhbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsT3B0aW9ucy5jb25zaXN0ZW50UmVhZClcbiAgICAgICAgICAgIGFkZENvbnNpc3RlbnRSZWFkSGVhZGVyKGxvY2FsSGVhZGVycyk7XG4gICAgICAgICAgcmV0dXJuIGZldGNoKGAke2Jhc2VVcmx9L2l0ZW0vJHtrZXl9P3ZlcnNpb249JHt2ZXJzaW9uMn1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgICAgICAgICAgaGVhZGVyczogbG9jYWxIZWFkZXJzLFxuICAgICAgICAgICAgY2FjaGU6IGZldGNoQ2FjaGVcbiAgICAgICAgICB9KS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpIHRocm93IG5ldyBFcnJvcihFUlJPUlMuVU5BVVRIT1JJWkVEKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgaWYgKHJlcy5oZWFkZXJzLmhhcyhcIngtZWRnZS1jb25maWctZGlnZXN0XCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuRURHRV9DT05GSUdfTk9UX0ZPVU5EKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMub2spIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWROZXR3b3JrRXJyb3IocmVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBuYW1lOiBcImhhc1wiLCBpc1ZlcmJvc2VUcmFjZTogZmFsc2UsIGF0dHJpYnV0ZXM6IHsgZWRnZUNvbmZpZ0lkIH0gfVxuICAgICAgKSxcbiAgICAgIGdldEFsbDogdHJhY2UoXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldEFsbDIoa2V5cywgbG9jYWxPcHRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxFZGdlQ29uZmlnID0gYXdhaXQgZ2V0SW5NZW1vcnlFZGdlQ29uZmlnKGxvY2FsT3B0aW9ucykgfHwgYXdhaXQgZ2V0TG9jYWxFZGdlQ29uZmlnKGNvbm5lY3Rpb24sIGxvY2FsT3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGxvY2FsRWRnZUNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxvY2FsRWRnZUNvbmZpZy5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJc0tleXMoa2V5cyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBpY2sobG9jYWxFZGdlQ29uZmlnLml0ZW1zLCBrZXlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSBhc3NlcnRJc0tleXMoa2V5cyk7XG4gICAgICAgICAgY29uc3Qgc2VhcmNoID0gQXJyYXkuaXNBcnJheShrZXlzKSA/IG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgICAgICAgICBrZXlzLmZpbHRlcigoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmICFpc0VtcHR5S2V5KGtleSkpLm1hcCgoa2V5KSA9PiBbXCJrZXlcIiwga2V5XSlcbiAgICAgICAgICApLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgICAgIGlmIChzZWFyY2ggPT09IFwiXCIpIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgICAgICAgIGNvbnN0IGxvY2FsSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICAgIGlmIChsb2NhbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsT3B0aW9ucy5jb25zaXN0ZW50UmVhZClcbiAgICAgICAgICAgIGFkZENvbnNpc3RlbnRSZWFkSGVhZGVyKGxvY2FsSGVhZGVycyk7XG4gICAgICAgICAgcmV0dXJuIGZldGNoV2l0aENhY2hlZFJlc3BvbnNlKFxuICAgICAgICAgICAgYCR7YmFzZVVybH0vaXRlbXM/dmVyc2lvbj0ke3ZlcnNpb24yfSR7c2VhcmNoID09PSBudWxsID8gXCJcIiA6IGAmJHtzZWFyY2h9YH1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBoZWFkZXJzOiBsb2NhbEhlYWRlcnMsXG4gICAgICAgICAgICAgIGNhY2hlOiBmZXRjaENhY2hlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMub2spIHJldHVybiByZXMuanNvbigpO1xuICAgICAgICAgICAgYXdhaXQgY29uc3VtZVJlc3BvbnNlQm9keShyZXMpO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5VTkFVVEhPUklaRUQpO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5FREdFX0NPTkZJR19OT1RfRk9VTkQpO1xuICAgICAgICAgICAgaWYgKHJlcy5jYWNoZWRSZXNwb25zZUJvZHkgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy5jYWNoZWRSZXNwb25zZUJvZHk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZE5ldHdvcmtFcnJvcihyZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB7IG5hbWU6IFwiZ2V0QWxsXCIsIGlzVmVyYm9zZVRyYWNlOiBmYWxzZSwgYXR0cmlidXRlczogeyBlZGdlQ29uZmlnSWQgfSB9XG4gICAgICApLFxuICAgICAgZGlnZXN0OiB0cmFjZShcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZGlnZXN0Mihsb2NhbE9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRJbk1lbW9yeUVkZ2VDb25maWcobG9jYWxPcHRpb25zKSB8fCBhd2FpdCBnZXRMb2NhbEVkZ2VDb25maWcoY29ubmVjdGlvbiwgbG9jYWxPcHRpb25zKTtcbiAgICAgICAgICBpZiAobG9jYWxFZGdlQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxvY2FsRWRnZUNvbmZpZy5kaWdlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsb2NhbEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICBpZiAobG9jYWxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBsb2NhbE9wdGlvbnMuY29uc2lzdGVudFJlYWQpXG4gICAgICAgICAgICBhZGRDb25zaXN0ZW50UmVhZEhlYWRlcihsb2NhbEhlYWRlcnMpO1xuICAgICAgICAgIHJldHVybiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZShcbiAgICAgICAgICAgIGAke2Jhc2VVcmx9L2RpZ2VzdD92ZXJzaW9uPSR7dmVyc2lvbjJ9YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGVhZGVyczogbG9jYWxIZWFkZXJzLFxuICAgICAgICAgICAgICBjYWNoZTogZmV0Y2hDYWNoZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzLm9rKSByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbnN1bWVSZXNwb25zZUJvZHkocmVzKTtcbiAgICAgICAgICAgIGlmIChyZXMuY2FjaGVkUmVzcG9uc2VCb2R5ICE9PSB2b2lkIDApXG4gICAgICAgICAgICAgIHJldHVybiByZXMuY2FjaGVkUmVzcG9uc2VCb2R5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWROZXR3b3JrRXJyb3IocmVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBuYW1lOiBcImRpZ2VzdFwiLCBpc1ZlcmJvc2VUcmFjZTogZmFsc2UsIGF0dHJpYnV0ZXM6IHsgZWRnZUNvbmZpZ0lkIH0gfVxuICAgICAgKVxuICAgIH07XG4gICAgcmV0dXJuIHsgLi4uYXBpLCBjb25uZWN0aW9uIH07XG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcImNyZWF0ZUNsaWVudFwiXG4gIH1cbik7XG52YXIgZGVmYXVsdEVkZ2VDb25maWdDbGllbnQ7XG5mdW5jdGlvbiBpbml0KCkge1xuICBpZiAoIWRlZmF1bHRFZGdlQ29uZmlnQ2xpZW50KSB7XG4gICAgZGVmYXVsdEVkZ2VDb25maWdDbGllbnQgPSBjcmVhdGVDbGllbnQocHJvY2Vzcy5lbnYuRURHRV9DT05GSUcpO1xuICB9XG59XG52YXIgZ2V0ID0gKC4uLmFyZ3MpID0+IHtcbiAgaW5pdCgpO1xuICByZXR1cm4gZGVmYXVsdEVkZ2VDb25maWdDbGllbnQuZ2V0KC4uLmFyZ3MpO1xufTtcbnZhciBnZXRBbGwgPSAoLi4uYXJncykgPT4ge1xuICBpbml0KCk7XG4gIHJldHVybiBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudC5nZXRBbGwoLi4uYXJncyk7XG59O1xudmFyIGhhcyA9ICguLi5hcmdzKSA9PiB7XG4gIGluaXQoKTtcbiAgcmV0dXJuIGRlZmF1bHRFZGdlQ29uZmlnQ2xpZW50LmhhcyguLi5hcmdzKTtcbn07XG52YXIgZGlnZXN0ID0gKC4uLmFyZ3MpID0+IHtcbiAgaW5pdCgpO1xuICByZXR1cm4gZGVmYXVsdEVkZ2VDb25maWdDbGllbnQuZGlnZXN0KC4uLmFyZ3MpO1xufTtcbmZ1bmN0aW9uIGNsb25lMyhlZGdlQ29uZmlnVmFsdWUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZWRnZUNvbmZpZ1ZhbHVlKSk7XG59XG5leHBvcnQge1xuICBjbG9uZTMgYXMgY2xvbmUsXG4gIGNyZWF0ZUNsaWVudCxcbiAgZGlnZXN0LFxuICBnZXQsXG4gIGdldEFsbCxcbiAgaGFzLFxuICBwYXJzZUNvbm5lY3Rpb25TdHJpbmcsXG4gIHNldFRyYWNlclByb3ZpZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@vercel/edge-config/dist/index.js\n");

/***/ })

};
;